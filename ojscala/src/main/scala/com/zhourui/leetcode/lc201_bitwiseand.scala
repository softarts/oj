package com.zhourui.leetcode

//看题感觉需要对所有的[m,n]范围内的数字进行遍历一遍吧。。其实不需要的。
//
//我们知道，数组的数字是连续的，那么m,n范围内的二进制表示的末尾相同位置一定会出现不同的0,1.我们只要找出m,n的做左边起的最长相同的二进制头部即可呀。
//
//如[5, 7]里共有三个数字，分别写出它们的二进制为：
//
//101　　110　　111
//
//相与后的结果为100，仔细观察我们可以得出，最后的数是该数字范围内所有的数的左边共同的部分（即m,n左边的共同部分），如果上面那个例子不太明显，我们再来看一个范围[26, 30]，它们的二进制如下：
//
//11010　　11011　　11100　　11101　　11110
//
//也是前两位是11，后面3位在不同数字中一定会出现0和1、相与即为0了。
//————————————————
//版权声明：本文为CSDN博主「负雪明烛」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
//原文链接：https://blog.csdn.net/fuxuemingzhu/article/details/79495633

class lc201_bitwiseand {
  object Solution {
    def rangeBitwiseAnd(m: Int, n: Int): Int = {
      var count = 0
      var m1 = m
      var n1 = n
      while (m1!=n1) {
        m1 >>= 1
        n1 >>=1
        count+=1
      }
      m1<<count
    }
  }
}
